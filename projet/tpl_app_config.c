/**
 * @file tpl_app_config.c
 *
 * @section desc File description
 *
 * OS data structure generated from application test
 * Automatically generated by goil on Tue Mar  3 11:48:21 2020
 * from root OIL file projet.oil
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#include "tpl_app_config.h"

#include "tpl_os_internal_types.h"
#include "tpl_machine.h"
#include "tpl_os_it.h"
#include "tpl_os_it_kernel.h"
#include "tpl_os_alarm_kernel.h"
#include "tpl_os_alarm.h"
#include "tpl_os_rez_kernel.h"
#include "tpl_os_rez.h"
#include "tpl_os_event_kernel.h"
#include "tpl_os_event.h"
#include "tpl_os_action.h"
#include "tpl_os_kernel.h"
#include "tpl_os_definitions.h"


#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

/*=============================================================================
 * Declaration of event masks
 */

/* Event droite */
#define droite_mask 1
CONST(EventMaskType, AUTOMATIC) droite = droite_mask;

/*=============================================================================
 * Declaration of processes IDs
 */

/* Task get_sonar identifier */
#define get_sonar_id 0
CONST(TaskType, AUTOMATIC) get_sonar = get_sonar_id;

/* Task init identifier */
#define init_id 1
CONST(TaskType, AUTOMATIC) init = init_id;

/* Task task_bump_both identifier */
#define task_bump_both_id 2
CONST(TaskType, AUTOMATIC) task_bump_both = task_bump_both_id;

/* Task task_bump_left identifier */
#define task_bump_left_id 3
CONST(TaskType, AUTOMATIC) task_bump_left = task_bump_left_id;

/* Task task_bump_right identifier */
#define task_bump_right_id 4
CONST(TaskType, AUTOMATIC) task_bump_right = task_bump_right_id;

/* Task task_sonar identifier */
#define task_sonar_id 5
CONST(TaskType, AUTOMATIC) task_sonar = task_sonar_id;

/* Task taskmain identifier */
#define taskmain_id 6
CONST(TaskType, AUTOMATIC) taskmain = taskmain_id;

/* ISR isr_button_left identifier */
#define isr_button_left_id 7
/* ISR isr_button_right identifier */
#define isr_button_right_id 8
/* ISR isr_button_start identifier */
#define isr_button_start_id 9
/* ISR isr_button_stop identifier */
#define isr_button_stop_id 10
#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_resource, AUTOMATIC, OS_APPL_DATA)
tpl_resource_table[RESOURCE_COUNT] = {
  &res_sched_rez_desc  
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of Counters related defines and structures
 */
/*-----------------------------------------------------------------------------
 * Counter SystemCounter descriptor
 */

#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_tick, OS_CONST) OSTICKSPERBASE = 1;
CONST(tpl_tick, OS_CONST) OSMAXALLOWEDVALUE = 2000;
CONST(tpl_tick, OS_CONST) OSMINCYCLE = 1;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_counter, OS_VAR) SystemCounter_counter_desc = {
  /* ticks per base       */  1,
  /* max allowed value    */  2000,
  /* minimum cycle        */  1,
  /* current tick         */  0,
  /* current date         */  0,
#if WITH_OSAPPLICATION == YES
    /* OS Application id    */  
#endif
    /* first alarm          */  NULL_PTR,
    /* next alarm to raise  */  NULL_PTR
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#include "tpl_os_kernel.h"          /* tpl_schedule */
#include "tpl_os_timeobj_kernel.h"  /* tpl_counter_tick */
#include "tpl_machine_interface.h"  /* tpl_switch_context_from_it */
#include "AT91SAM7.h" /* AT91C_AIC_ISCR */

#define OS_START_SEC_VAR_8BIT
#include "tpl_memmap.h"
VAR(u8, OS_VAR) check_buttons_period = 0;
#define OS_STOP_SEC_VAR_8BIT
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

FUNC(void, OS_CODE) tpl_tick_it_timer1()
{
  tpl_status  need_rescheduling = NO_SPECIAL_CODE;

  need_rescheduling |= tpl_counter_tick(&SystemCounter_counter_desc);

  
  check_buttons_period++;
  if (check_buttons_period == 10)
  {
    /* Call check_buttons_status() (via interrupts)
     * which will check if buttons are pressed or not.
     */
     *AT91C_AIC_ISCR = (1 << AT91C_PERIPHERAL_ID_IRQ0);
     check_buttons_period = 0;
  }

  if (need_rescheduling == NEED_RESCHEDULING)
  {
    tpl_schedule_from_running();
#if WITH_SYSTEM_CALL == NO
    if (tpl_kern.need_switch != NO_NEED_SWITCH) {
      tpl_switch_context_from_it(
        &(tpl_kern.s_old->context),
        &(tpl_kern.s_running->context)
      );
    }
#endif
  }
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of Task related defines and structures
 */
/*-----------------------------------------------------------------------------
 * Task get_sonar descriptor
 */
#define APP_Task_get_sonar_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task get_sonar function prototype
 */
FUNC(void, OS_APPL_CODE) get_sonar_function(void);
#define APP_Task_get_sonar_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task get_sonar stack
 */
#define APP_Task_get_sonar_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) get_sonar_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_get_sonar_STOP_SEC_STACK
#include "tpl_memmap.h"

#define get_sonar_STACK {get_sonar_stack_zone, 500}

/*
 * Task get_sonar context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) get_sonar_int_context;

#define get_sonar_CONTEXT &get_sonar_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task get_sonar
 */
CONST(tpl_proc_static, OS_CONST) get_sonar_task_stat_desc = {
  /* context                  */  get_sonar_CONTEXT,
  /* stack                    */  get_sonar_STACK,
  /* entry point (function)   */  get_sonar_function,
  /* internal ressource       */  NULL,
  /* task id                  */  get_sonar_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_EXTENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task get_sonar
 */
VAR(tpl_proc, OS_VAR) get_sonar_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
};

/*
 * Event structure of task get_sonar
 */
VAR(tpl_task_events, OS_VAR) get_sonar_task_evts = {
  /* event set  */ 0,
  /* event wait */ 0
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task init descriptor
 */
#define APP_Task_init_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task init function prototype
 */
FUNC(void, OS_APPL_CODE) init_function(void);
#define APP_Task_init_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task init stack
 */
#define APP_Task_init_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) init_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_init_STOP_SEC_STACK
#include "tpl_memmap.h"

#define init_STACK {init_stack_zone, 500}

/*
 * Task init context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) init_int_context;

#define init_CONTEXT &init_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task init
 */
CONST(tpl_proc_static, OS_CONST) init_task_stat_desc = {
  /* context                  */  init_CONTEXT,
  /* stack                    */  init_STACK,
  /* entry point (function)   */  init_function,
  /* internal ressource       */  NULL,
  /* task id                  */  init_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task init
 */
VAR(tpl_proc, OS_VAR) init_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  AUTOSTART
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task task_bump_both descriptor
 */
#define APP_Task_task_bump_both_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task task_bump_both function prototype
 */
FUNC(void, OS_APPL_CODE) task_bump_both_function(void);
#define APP_Task_task_bump_both_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task task_bump_both stack
 */
#define APP_Task_task_bump_both_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) task_bump_both_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_task_bump_both_STOP_SEC_STACK
#include "tpl_memmap.h"

#define task_bump_both_STACK {task_bump_both_stack_zone, 500}

/*
 * Task task_bump_both context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) task_bump_both_int_context;

#define task_bump_both_CONTEXT &task_bump_both_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task task_bump_both
 */
CONST(tpl_proc_static, OS_CONST) task_bump_both_task_stat_desc = {
  /* context                  */  task_bump_both_CONTEXT,
  /* stack                    */  task_bump_both_STACK,
  /* entry point (function)   */  task_bump_both_function,
  /* internal ressource       */  NULL,
  /* task id                  */  task_bump_both_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task task_bump_both
 */
VAR(tpl_proc, OS_VAR) task_bump_both_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task task_bump_left descriptor
 */
#define APP_Task_task_bump_left_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task task_bump_left function prototype
 */
FUNC(void, OS_APPL_CODE) task_bump_left_function(void);
#define APP_Task_task_bump_left_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task task_bump_left stack
 */
#define APP_Task_task_bump_left_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) task_bump_left_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_task_bump_left_STOP_SEC_STACK
#include "tpl_memmap.h"

#define task_bump_left_STACK {task_bump_left_stack_zone, 500}

/*
 * Task task_bump_left context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) task_bump_left_int_context;

#define task_bump_left_CONTEXT &task_bump_left_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task task_bump_left
 */
CONST(tpl_proc_static, OS_CONST) task_bump_left_task_stat_desc = {
  /* context                  */  task_bump_left_CONTEXT,
  /* stack                    */  task_bump_left_STACK,
  /* entry point (function)   */  task_bump_left_function,
  /* internal ressource       */  NULL,
  /* task id                  */  task_bump_left_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task task_bump_left
 */
VAR(tpl_proc, OS_VAR) task_bump_left_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task task_bump_right descriptor
 */
#define APP_Task_task_bump_right_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task task_bump_right function prototype
 */
FUNC(void, OS_APPL_CODE) task_bump_right_function(void);
#define APP_Task_task_bump_right_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task task_bump_right stack
 */
#define APP_Task_task_bump_right_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) task_bump_right_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_task_bump_right_STOP_SEC_STACK
#include "tpl_memmap.h"

#define task_bump_right_STACK {task_bump_right_stack_zone, 500}

/*
 * Task task_bump_right context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) task_bump_right_int_context;

#define task_bump_right_CONTEXT &task_bump_right_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task task_bump_right
 */
CONST(tpl_proc_static, OS_CONST) task_bump_right_task_stat_desc = {
  /* context                  */  task_bump_right_CONTEXT,
  /* stack                    */  task_bump_right_STACK,
  /* entry point (function)   */  task_bump_right_function,
  /* internal ressource       */  NULL,
  /* task id                  */  task_bump_right_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task task_bump_right
 */
VAR(tpl_proc, OS_VAR) task_bump_right_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task task_sonar descriptor
 */
#define APP_Task_task_sonar_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task task_sonar function prototype
 */
FUNC(void, OS_APPL_CODE) task_sonar_function(void);
#define APP_Task_task_sonar_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task task_sonar stack
 */
#define APP_Task_task_sonar_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) task_sonar_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_task_sonar_STOP_SEC_STACK
#include "tpl_memmap.h"

#define task_sonar_STACK {task_sonar_stack_zone, 500}

/*
 * Task task_sonar context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) task_sonar_int_context;

#define task_sonar_CONTEXT &task_sonar_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task task_sonar
 */
CONST(tpl_proc_static, OS_CONST) task_sonar_task_stat_desc = {
  /* context                  */  task_sonar_CONTEXT,
  /* stack                    */  task_sonar_STACK,
  /* entry point (function)   */  task_sonar_function,
  /* internal ressource       */  NULL,
  /* task id                  */  task_sonar_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task task_sonar
 */
VAR(tpl_proc, OS_VAR) task_sonar_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task taskmain descriptor
 */
#define APP_Task_taskmain_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task taskmain function prototype
 */
FUNC(void, OS_APPL_CODE) taskmain_function(void);
#define APP_Task_taskmain_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task taskmain stack
 */
#define APP_Task_taskmain_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) taskmain_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_taskmain_STOP_SEC_STACK
#include "tpl_memmap.h"

#define taskmain_STACK {taskmain_stack_zone, 500}

/*
 * Task taskmain context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) taskmain_int_context;

#define taskmain_CONTEXT &taskmain_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task taskmain
 */
CONST(tpl_proc_static, OS_CONST) taskmain_task_stat_desc = {
  /* context                  */  taskmain_CONTEXT,
  /* stack                    */  taskmain_STACK,
  /* entry point (function)   */  taskmain_function,
  /* internal ressource       */  NULL,
  /* task id                  */  taskmain_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task taskmain
 */
VAR(tpl_proc, OS_VAR) taskmain_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of ISR2 related defines and structures
 */
/*-----------------------------------------------------------------------------
 * ISR isr_button_left descriptor
 */
#define APP_ISR_isr_button_left_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR isr_button_left function prototype
 */
FUNC(void, OS_APPL_CODE) isr_button_left_function(void);
#define APP_ISR_isr_button_left_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * ISR isr_button_left stack
 */
#define APP_ISR_isr_button_left_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) isr_button_left_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_ISR_isr_button_left_STOP_SEC_STACK
#include "tpl_memmap.h"

#define isr_button_left_STACK {isr_button_left_stack_zone, 500}

/*
 * ISR isr_button_left context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) isr_button_left_int_context;

#define isr_button_left_CONTEXT &isr_button_left_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



/*
  No timing protection
 */

#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR isr_button_left
 */
CONST(tpl_proc_static, OS_CONST) isr_button_left_isr_stat_desc = {
  /* context                  */  isr_button_left_CONTEXT,
  /* stack                    */  isr_button_left_STACK,
  /* entry point (function)   */  isr_button_left_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  isr_button_left_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  2,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

CONST(tpl_isr_static, OS_CONST) isr_button_left_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     isr_button_left_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR isr_button_left
 */
VAR(tpl_proc, OS_VAR) isr_button_left_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  2,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR isr_button_right descriptor
 */
#define APP_ISR_isr_button_right_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR isr_button_right function prototype
 */
FUNC(void, OS_APPL_CODE) isr_button_right_function(void);
#define APP_ISR_isr_button_right_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * ISR isr_button_right stack
 */
#define APP_ISR_isr_button_right_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) isr_button_right_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_ISR_isr_button_right_STOP_SEC_STACK
#include "tpl_memmap.h"

#define isr_button_right_STACK {isr_button_right_stack_zone, 500}

/*
 * ISR isr_button_right context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) isr_button_right_int_context;

#define isr_button_right_CONTEXT &isr_button_right_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



/*
  No timing protection
 */

#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR isr_button_right
 */
CONST(tpl_proc_static, OS_CONST) isr_button_right_isr_stat_desc = {
  /* context                  */  isr_button_right_CONTEXT,
  /* stack                    */  isr_button_right_STACK,
  /* entry point (function)   */  isr_button_right_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  isr_button_right_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  2,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

CONST(tpl_isr_static, OS_CONST) isr_button_right_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     isr_button_right_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR isr_button_right
 */
VAR(tpl_proc, OS_VAR) isr_button_right_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  2,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR isr_button_start descriptor
 */
#define APP_ISR_isr_button_start_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR isr_button_start function prototype
 */
FUNC(void, OS_APPL_CODE) isr_button_start_function(void);
#define APP_ISR_isr_button_start_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * ISR isr_button_start stack
 */
#define APP_ISR_isr_button_start_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) isr_button_start_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_ISR_isr_button_start_STOP_SEC_STACK
#include "tpl_memmap.h"

#define isr_button_start_STACK {isr_button_start_stack_zone, 500}

/*
 * ISR isr_button_start context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) isr_button_start_int_context;

#define isr_button_start_CONTEXT &isr_button_start_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



/*
  No timing protection
 */

#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR isr_button_start
 */
CONST(tpl_proc_static, OS_CONST) isr_button_start_isr_stat_desc = {
  /* context                  */  isr_button_start_CONTEXT,
  /* stack                    */  isr_button_start_STACK,
  /* entry point (function)   */  isr_button_start_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  isr_button_start_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  2,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

CONST(tpl_isr_static, OS_CONST) isr_button_start_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     isr_button_start_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR isr_button_start
 */
VAR(tpl_proc, OS_VAR) isr_button_start_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  2,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR isr_button_stop descriptor
 */
#define APP_ISR_isr_button_stop_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR isr_button_stop function prototype
 */
FUNC(void, OS_APPL_CODE) isr_button_stop_function(void);
#define APP_ISR_isr_button_stop_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * ISR isr_button_stop stack
 */
#define APP_ISR_isr_button_stop_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) isr_button_stop_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_ISR_isr_button_stop_STOP_SEC_STACK
#include "tpl_memmap.h"

#define isr_button_stop_STACK {isr_button_stop_stack_zone, 500}

/*
 * ISR isr_button_stop context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(arm_context, OS_VAR) isr_button_stop_int_context;

#define isr_button_stop_CONTEXT &isr_button_stop_int_context

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"



/*
  No timing protection
 */

#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR isr_button_stop
 */
CONST(tpl_proc_static, OS_CONST) isr_button_stop_isr_stat_desc = {
  /* context                  */  isr_button_stop_CONTEXT,
  /* stack                    */  isr_button_stop_STACK,
  /* entry point (function)   */  isr_button_stop_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  isr_button_stop_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  2,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

CONST(tpl_isr_static, OS_CONST) isr_button_stop_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     isr_button_stop_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR isr_button_stop
 */
VAR(tpl_proc, OS_VAR) isr_button_stop_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  2,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#include "tpl_machine.h"


/* Interrupt functions */

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

FUNC(void, OS_CODE) tpl_interrupt_source_1()
{

  tpl_tick_it_timer1();

  systick_isr_C_function(); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_2()
{

  nxt_motor_isr_C_function(); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_5()
{

  spi_isr_C_function(); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_7()
{

  bt_isr_C_function(); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_9()
{

  twi_isr_C_function(); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_10()
{

  systick_low_priority_C_function(); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_12()
{

  i2c_timer_isr_C_function(); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_15()
{

  tpl_central_interrupt_handler(9); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_16()
{

  tpl_central_interrupt_handler(7); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_17()
{

  tpl_central_interrupt_handler(8); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_18()
{

  tpl_central_interrupt_handler(10); 
}

FUNC(void, OS_CODE) tpl_interrupt_source_30()
{

  check_buttons_status_function(); 
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


/* Interrupt table vector */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONST(tpl_it_vector_entry, OS_CONST) tpl_it_vector[31] = {
  { tpl_null_it, (void *)NULL },
  { tpl_interrupt_source_1, (void *)NULL },
  { tpl_interrupt_source_2, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_interrupt_source_5, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_interrupt_source_7, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_interrupt_source_9, (void *)NULL },
  { tpl_interrupt_source_10, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_interrupt_source_12, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_interrupt_source_15, (void *)NULL },
  { tpl_interrupt_source_16, (void *)NULL },
  { tpl_interrupt_source_17, (void *)NULL },
  { tpl_interrupt_source_18, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_null_it, (void *)NULL },
  { tpl_interrupt_source_30, (void *)NULL }
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
/*=============================================================================
 * Definition and initialization of process tables (tasks and isrs)
 */
CONSTP2CONST(tpl_proc_static, AUTOMATIC, OS_APPL_DATA)
tpl_stat_proc_table[TASK_COUNT+ISR_COUNT+1] = {
  &get_sonar_task_stat_desc,
  &init_task_stat_desc,
  &task_bump_both_task_stat_desc,
  &task_bump_left_task_stat_desc,
  &task_bump_right_task_stat_desc,
  &task_sonar_task_stat_desc,
  &taskmain_task_stat_desc,
  &isr_button_left_isr_stat_desc,
  &isr_button_right_isr_stat_desc,
  &isr_button_start_isr_stat_desc,
  &isr_button_stop_isr_stat_desc,
  &idle_task_static
};

CONSTP2VAR(tpl_proc, AUTOMATIC, OS_APPL_DATA)
tpl_dyn_proc_table[TASK_COUNT+ISR_COUNT+1] = {
  &get_sonar_task_desc,
  &init_task_desc,
  &task_bump_both_task_desc,
  &task_bump_left_task_desc,
  &task_bump_right_task_desc,
  &task_sonar_task_desc,
  &taskmain_task_desc,
  &isr_button_left_isr_desc,
  &isr_button_right_isr_desc,
  &isr_button_start_isr_desc,
  &isr_button_stop_isr_desc,
  &idle_task
};

CONSTP2VAR(tpl_task_events, AUTOMATIC, OS_APPL_DATA)
tpl_task_events_table[EXTENDED_TASK_COUNT] = {
  &get_sonar_task_evts
};

CONSTP2CONST(tpl_isr_static, AUTOMATIC, OS_APPL_DATA)
tpl_isr_stat_table[ISR_COUNT] = {
  &isr_button_left_isr_helper,
  &isr_button_right_isr_helper,
  &isr_button_start_isr_helper,
  &isr_button_stop_isr_helper
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Declaration of flags functions
 */
/* $FLAGSFUNCTIONS$ */


/*=============================================================================
 * Definition and initialization of Ready List structures
 */
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_proc_id, OS_VAR) tpl_priority_0_fifo[1];
VAR(tpl_proc_id, OS_VAR) tpl_priority_1_fifo[8];
VAR(tpl_proc_id, OS_VAR) tpl_priority_2_fifo[12];

VAR(tpl_fifo_state, OS_VAR) tpl_fifo_rw[3] = {
  { 0 , 0 },
  { 0 , 0 },
  { 0 , 0 }
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_priority_level, OS_CONST) tpl_ready_list[3] = {
  { tpl_priority_0_fifo, 1 },
  { tpl_priority_1_fifo, 8 },
  { tpl_priority_2_fifo, 12 }
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2CONST(char, AUTOMATIC, OS_APPL_DATA) proc_name_table[TASK_COUNT + ISR_COUNT] = {
  "get_sonar",
  "init",
  "task_bump_both",
  "task_bump_left",
  "task_bump_right",
  "task_sonar",
  "taskmain",
  "isr_button_left",
  "isr_button_right",
  "isr_button_start",
  "isr_button_stop"
};
#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

/* End of file tpl_app_config.c */
